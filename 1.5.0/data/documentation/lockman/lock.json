{"abstract":[{"type":"text","text":"Understanding the locking mechanism in Lockman."}],"schemaVersion":{"major":0,"patch":0,"minor":3},"sections":[],"metadata":{"modules":[{"name":"Lockman"}],"role":"article","title":"Lock","roleHeading":"Article"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Lockman\/documentation\/Lockman\/Lock"},"seeAlsoSections":[{"generated":true,"anchor":"Essentials","title":"Essentials","identifiers":["doc:\/\/Lockman\/documentation\/Lockman\/GettingStarted","doc:\/\/Lockman\/documentation\/Lockman\/BoundaryOverview","doc:\/\/Lockman\/documentation\/Lockman\/Unlock","doc:\/\/Lockman\/documentation\/Lockman\/ChoosingStrategy","doc:\/\/Lockman\/documentation\/Lockman\/Configuration","doc:\/\/Lockman\/documentation\/Lockman\/ErrorHandling","doc:\/\/Lockman\/documentation\/Lockman\/DebuggingGuide"]}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"inlineContent":[{"type":"text","text":"Locking in Lockman is a strategy-based exclusive control system. Unlike traditional simple ON\/OFF control, the selected strategy enables various types of control:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Execution Prevention","type":"text"}]},{"text":": Blocking duplicate execution (","type":"text"},{"isActive":true,"overridingTitleInlineContent":[{"text":"SingleExecutionStrategy","type":"text"}],"type":"reference","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/SingleExecutionStrategy","overridingTitle":"SingleExecutionStrategy"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Execution Priority","type":"text"}]},{"type":"text","text":": Prioritizing new operations by interrupting existing operations ("},{"type":"reference","isActive":true,"overridingTitle":"PriorityBasedStrategy","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/PriorityBasedStrategy","overridingTitleInlineContent":[{"type":"text","text":"PriorityBasedStrategy"}]},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Execution Coordination","type":"text"}],"type":"strong"},{"text":": Coordinating related operation groups (","type":"text"},{"isActive":true,"overridingTitle":"GroupCoordinationStrategy","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/GroupCoordinationStrategy","overridingTitleInlineContent":[{"type":"text","text":"GroupCoordinationStrategy"}],"type":"reference"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Execution Limitation","type":"text"}],"type":"strong"},{"text":": Limiting concurrent execution count (","type":"text"},{"overridingTitle":"ConcurrencyLimitedStrategy","overridingTitleInlineContent":[{"type":"text","text":"ConcurrencyLimitedStrategy"}],"isActive":true,"type":"reference","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/ConcurrencyLimitedStrategy"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Conditional Execution Control","type":"text"}],"type":"strong"},{"text":": Dynamic conditional control through custom logic (","type":"text"},{"overridingTitle":"DynamicConditionStrategy","overridingTitleInlineContent":[{"text":"DynamicConditionStrategy","type":"text"}],"type":"reference","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/DynamicConditionStrategy","isActive":true},{"text":")","type":"text"}]}]}]},{"level":2,"text":"Specifications","type":"heading","anchor":"Specifications"},{"inlineContent":[{"text":"Lockman determines the success or failure of lock acquisition based on the strategy and executes operations according to the result. The lock acquisition judgment process follows the rules of the specified strategy, and when multiple strategies are specified with ","type":"text"},{"identifier":"doc:\/\/Lockman\/documentation\/Lockman\/CompositeStrategy","overridingTitle":"CompositeStrategy","isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"CompositeStrategy"}],"type":"reference"},{"text":", lock acquisition succeeds only when all strategies allow it.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Methods","type":"heading","anchor":"Methods"},{"inlineContent":[{"type":"text","text":"Lockman provides several methods that can be used according to different purposes."}],"type":"paragraph"},{"level":3,"text":"Reducer.lock (Automatic Lock Management)","type":"heading","anchor":"Reducerlock-Automatic-Lock-Management"},{"inlineContent":[{"type":"text","text":"The recommended approach for most use cases. Applies automatic lock management to all effects produced by actions implementing "},{"type":"codeVoice","code":"LockmanAction"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["@Reducer","struct Feature {","  var body: some ReducerOf<Self> {","    Reduce { state, action in","      switch action {","      case .fetch:","        return .run { send in","          \/\/ This effect will be automatically locked","          let data = try await fetchData()","          await send(.fetchResponse(.success(data)))","        }","      case .fetchResponse:","        return .none","      }","    }","    .lock(","      boundaryId: CancelID.feature,","      unlockOption: .immediate, \/\/ Optional","      lockFailure: { error, send in \/\/ Optional","        await send(.lockFailed)","      }","    )","  }","}"]},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Parameters:","type":"text"}]}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"boundaryId"},{"type":"text","text":": Boundary identifier (exclusive control scope) for all locked actions"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"unlockOption"},{"type":"text","text":": Default lock release timing (optional)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"lockFailure","type":"codeVoice"},{"type":"text","text":": Handler for lock acquisition failures (optional)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"for"},{"type":"text","text":": Case paths to check for nested LockmanAction conformance (optional, up to 5 paths)"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Features:"}]}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Automatic lock management for LockmanAction effects"}]}]},{"content":[{"inlineContent":[{"text":"Non-LockmanAction effects pass through unchanged","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Centralized error handling"}]}]},{"content":[{"inlineContent":[{"text":"Seamless integration with existing reducers","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Support for nested actions via CasePaths","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"inlineContent":[{"text":"Nested Action Support:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"When using the ViewAction pattern in TCA, actions may be nested within enum cases. The ","type":"text"},{"code":"lock","type":"codeVoice"},{"text":" method supports checking these nested actions:","type":"text"}]},{"code":["\/\/ Root action only (no paths)",".lock(boundaryId: CancelID.feature)","","\/\/ Check root and view actions",".lock(boundaryId: CancelID.feature, for: \\.view)","","\/\/ Check view and delegate actions",".lock(boundaryId: CancelID.feature, for: \\.view, \\.delegate)","","\/\/ Multiple overloads support up to 5 paths",".lock(","  boundaryId: CancelID.feature,","  for: \\.view, \\.delegate, \\.alert",")"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The method will check actions in the following order:"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"First, it checks if the root action conforms to "},{"type":"codeVoice","code":"LockmanAction"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"If not, it checks each provided path in order"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The first action found that conforms to ","type":"text"},{"code":"LockmanAction","type":"codeVoice"},{"text":" will be used for locking","type":"text"}],"type":"paragraph"}]}]},{"anchor":"Effectlock-Method-Chain-Style","type":"heading","level":3,"text":"Effect.lock (Method Chain Style)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A method chain API that applies lock management to an existing effect."}]},{"code":["return .run { send in","  \/\/ async operation","  let data = try await fetchData()","  await send(.fetchResponse(data))","}",".lock(","  action: action,","  boundaryId: Feature.self,","  unlockOption: .immediate, \/\/ Optional","  lockFailure: { error, send in \/\/ Optional","    await send(.lockFailed)","  }",")"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Parameters:"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"action"},{"type":"text","text":": Current action implementing LockmanAction"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"boundaryId"},{"type":"text","text":": Effect cancellation identifier"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"unlockOption"},{"type":"text","text":": Lock release timing (optional)"}]}]},{"content":[{"inlineContent":[{"code":"handleCancellationErrors","type":"codeVoice"},{"text":": Handling of cancellation errors (optional)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"lockFailure"},{"type":"text","text":": Handler for lock acquisition failure (optional)"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Features:"}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Method chain style for natural TCA integration","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Internally uses ","type":"text"},{"type":"codeVoice","code":"lock(concatenating:)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Same lock management guarantees"}]}]}]},{"anchor":"lockconcatenating","type":"heading","level":3,"text":"lock(concatenating:)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Maintains the same lock while executing multiple Effects sequentially."}]},{"code":[".lock(","  concatenating: [","    .run { send in \/* Processing 1 *\/ },","    .run { send in \/* Processing 2 *\/ },","    .run { send in \/* Processing 3 *\/ }","  ],","  unlockOption: .immediate, \/\/ Optional: Lock release timing","  lockFailure: { error, send in \/* Lock acquisition failure handling *\/ }, \/\/ Optional","  action: action,","  boundaryId: cancelID",")"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Features:"}]}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Maintains the same lock across multiple Effects","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Suitable for transactional operations","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"If any one fails, the entire process is interrupted","type":"text"}]}]}]},{"anchor":"UnlockOption-Priority","type":"heading","level":2,"text":"UnlockOption Priority"},{"type":"paragraph","inlineContent":[{"text":"When determining the unlock timing, Lockman follows this priority order:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Explicitly specified in method call","type":"text"}],"type":"strong"},{"text":" (highest priority)","type":"text"}]},{"syntax":"swift","type":"codeListing","code":[".lock(","  unlockOption: .transition, \/\/ This takes precedence","  action: action,","  boundaryId: cancelID",")"]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Action’s unlockOption property","type":"text"}]}],"type":"paragraph"},{"code":["struct MyAction: LockmanAction {","  var unlockOption: LockmanUnlockOption { .mainRunLoop }","  \/\/ ...","}"],"type":"codeListing","syntax":"swift"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Global configuration","type":"text"}],"type":"strong"},{"text":" (lowest priority)","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["LockmanManager.config.defaultUnlockOption = .immediate"]}]}]},{"type":"paragraph","inlineContent":[{"text":"This allows flexible control from global defaults to action-specific and call-specific overrides.","type":"text"}]}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/lockman\/lock"]}],"hierarchy":{"paths":[["doc:\/\/Lockman\/documentation\/Lockman"]]},"kind":"article","references":{"doc://Lockman/documentation/Lockman/Configuration":{"abstract":[{"text":"Configure Lockman for your application’s needs.","type":"text"}],"title":"Configuration","role":"article","url":"\/documentation\/lockman\/configuration","kind":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/Configuration","type":"topic"},"doc://Lockman/documentation/Lockman/PriorityBasedStrategy":{"type":"topic","kind":"article","abstract":[{"type":"text","text":"Control action execution based on priority levels."}],"title":"PriorityBasedStrategy","url":"\/documentation\/lockman\/prioritybasedstrategy","role":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/PriorityBasedStrategy"},"doc://Lockman/documentation/Lockman/BoundaryOverview":{"identifier":"doc:\/\/Lockman\/documentation\/Lockman\/BoundaryOverview","type":"topic","kind":"article","title":"Boundary","abstract":[{"type":"text","text":"Understand the concept of boundaries in Lockman."}],"role":"article","url":"\/documentation\/lockman\/boundaryoverview"},"doc://Lockman/documentation/Lockman/ErrorHandling":{"identifier":"doc:\/\/Lockman\/documentation\/Lockman\/ErrorHandling","type":"topic","kind":"article","url":"\/documentation\/lockman\/errorhandling","abstract":[{"type":"text","text":"Learn about common error handling patterns in Lockman."}],"role":"article","title":"Error Handling"},"doc://Lockman/documentation/Lockman":{"url":"\/documentation\/lockman","kind":"symbol","identifier":"doc:\/\/Lockman\/documentation\/Lockman","abstract":[{"type":"text","text":"Elegant exclusive control for user actions in The Composable Architecture applications."}],"title":"Lockman","type":"topic","role":"collection"},"doc://Lockman/documentation/Lockman/GettingStarted":{"role":"article","type":"topic","title":"Getting Started","kind":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/GettingStarted","url":"\/documentation\/lockman\/gettingstarted","abstract":[{"text":"Learn how to integrate Lockman into your TCA application.","type":"text"}]},"doc://Lockman/documentation/Lockman/ChoosingStrategy":{"title":"Choosing a Strategy","kind":"article","url":"\/documentation\/lockman\/choosingstrategy","type":"topic","abstract":[{"type":"text","text":"Learn how to select the right strategy for your use case."}],"identifier":"doc:\/\/Lockman\/documentation\/Lockman\/ChoosingStrategy","role":"article"},"doc://Lockman/documentation/Lockman/CompositeStrategy":{"kind":"article","type":"topic","url":"\/documentation\/lockman\/compositestrategy","role":"article","abstract":[{"type":"text","text":"Combine multiple strategies for complex control scenarios."}],"identifier":"doc:\/\/Lockman\/documentation\/Lockman\/CompositeStrategy","title":"CompositeStrategy"},"doc://Lockman/documentation/Lockman/Unlock":{"role":"article","type":"topic","kind":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/Unlock","url":"\/documentation\/lockman\/unlock","title":"Unlock","abstract":[{"type":"text","text":"Understanding the unlocking mechanism in Lockman."}]},"doc://Lockman/documentation/Lockman/ConcurrencyLimitedStrategy":{"type":"topic","kind":"article","title":"ConcurrencyLimitedStrategy","abstract":[{"type":"text","text":"Limit the number of concurrent executions."}],"url":"\/documentation\/lockman\/concurrencylimitedstrategy","role":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/ConcurrencyLimitedStrategy"},"doc://Lockman/documentation/Lockman/DebuggingGuide":{"role":"article","kind":"article","abstract":[{"text":"Learn how to debug Lockman-related issues in your application.","type":"text"}],"title":"Debugging Guide","type":"topic","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/DebuggingGuide","url":"\/documentation\/lockman\/debuggingguide"},"doc://Lockman/documentation/Lockman/DynamicConditionStrategy":{"kind":"article","role":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/DynamicConditionStrategy","abstract":[{"text":"Control actions based on runtime conditions with unified condition evaluation.","type":"text"}],"url":"\/documentation\/lockman\/dynamicconditionstrategy","title":"Dynamic Condition Evaluation","type":"topic"},"doc://Lockman/documentation/Lockman/GroupCoordinationStrategy":{"url":"\/documentation\/lockman\/groupcoordinationstrategy","type":"topic","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/GroupCoordinationStrategy","abstract":[{"text":"Coordinate actions through leader\/member group roles.","type":"text"}],"role":"article","title":"GroupCoordinationStrategy","kind":"article"},"doc://Lockman/documentation/Lockman/SingleExecutionStrategy":{"abstract":[{"type":"text","text":"Prevent duplicate execution of the same action."}],"type":"topic","kind":"article","url":"\/documentation\/lockman\/singleexecutionstrategy","role":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/SingleExecutionStrategy","title":"SingleExecutionStrategy"}}}