{"sections":[],"hierarchy":{"paths":[["doc:\/\/Lockman\/documentation\/Lockman"]]},"metadata":{"title":"Migrating to 1.5","roleHeading":"Article","role":"article","modules":[{"name":"Lockman"}]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Lockman\/documentation\/Lockman\/MigratingTo1.5"},"abstract":[{"type":"text","text":"Update your code from Lockman 1.4 to take advantage of Lockman 1.5â€™s unified dynamic condition evaluation API."}],"variants":[{"paths":["\/documentation\/lockman\/migratingto1.5"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"article","primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Lockman 1.5 introduces a major architectural improvement with the unified "},{"type":"codeVoice","code":"LockmanDynamicConditionReducer"},{"type":"text","text":" API. This change simplifies dynamic condition evaluation by eliminating the complex strategy-based approach in favor of a clean, two-level processing system."}]},{"type":"paragraph","inlineContent":[{"text":"The key changes include:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Unified API"}],"type":"strong"},{"text":": Replace complex ","type":"text"},{"type":"codeVoice","code":"LockmanDynamicConditionStrategy"},{"text":" with simplified ","type":"text"},{"type":"codeVoice","code":"LockmanDynamicConditionReducer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Two-level processing","type":"text"}]},{"type":"text","text":": Independent reducer-level and action-level condition evaluation"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Simplified architecture"}]},{"type":"text","text":": Direct condition evaluation + cancellable effect control"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Removed macros","type":"text"}],"type":"strong"},{"type":"text","text":": No more "},{"code":"@LockmanDynamicCondition","type":"codeVoice"},{"type":"text","text":" macro needed"}]}]}]},{"type":"heading","level":2,"text":"Updating dependencies","anchor":"Updating-dependencies"},{"type":"paragraph","inlineContent":[{"text":"To upgrade to Lockman 1.5, update your ","type":"text"},{"type":"codeVoice","code":"Package.swift"},{"text":" file:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","  .package(","    url: \"https:\/\/github.com\/takeshishimada\/Lockman\",","    from: \"1.5.0\"","  )","]"]},{"type":"heading","level":2,"text":"Breaking changes","anchor":"Breaking-changes"},{"type":"heading","level":3,"text":"`LockmanDynamicConditionStrategy` removed","anchor":"LockmanDynamicConditionStrategy-removed"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The entire strategy-based approach has been removed and replaced with a unified reducer-based API."}]},{"type":"paragraph","inlineContent":[{"text":"ðŸš« ","type":"text"},{"type":"strong","inlineContent":[{"text":"Removed in 1.5:","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ These are no longer available","LockmanDynamicConditionStrategy","LockmanDynamicConditionInfo","LockmanDynamicConditionAction","@LockmanDynamicCondition macro"]},{"type":"paragraph","inlineContent":[{"text":"âœ… ","type":"text"},{"type":"strong","inlineContent":[{"text":"New in 1.5:","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Unified condition evaluation","LockmanDynamicConditionReducer","Reducer.lock(condition:boundaryId:lockFailure:)","reducer.lock(state:action:operation:boundaryId:lockCondition:)"]},{"type":"heading","level":3,"text":"Macro-based action definition removed","anchor":"Macro-based-action-definition-removed"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@LockmanDynamicCondition"},{"type":"text","text":" macro is no longer available."}]},{"type":"paragraph","inlineContent":[{"text":"ðŸš« ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Before (1.4):"}]}]},{"type":"codeListing","syntax":"swift","code":["@LockmanDynamicCondition","enum Action {","  case transfer(amount: Double)","  case withdraw(amount: Double)","  ","  var lockmanInfo: LockmanDynamicConditionInfo {","    switch self {","    case .transfer(let amount):","      return LockmanDynamicConditionInfo(","        actionId: actionName,","        condition: { \/* condition logic *\/ }","      )","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"âœ… ","type":"text"},{"inlineContent":[{"text":"After (1.5):","type":"text"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ No macro needed - use regular enum","enum Action {","  case transfer(amount: Double)","  case withdraw(amount: Double)","}","","\/\/ Apply conditions directly in reducer",".lock(","  condition: { state, action in","    switch action {","    case .transfer(let amount):","      \/\/ Your condition logic here","      return state.balance >= amount ? .success : .cancel(InsufficientFundsError())","    default:","      return .success","    }","  },","  boundaryId: CancelID.financial",")"]},{"type":"heading","level":2,"text":"Migration guide","anchor":"Migration-guide"},{"type":"heading","level":3,"text":"Step 1: Remove macro usage","anchor":"Step-1-Remove-macro-usage"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Remove "},{"code":"@LockmanDynamicCondition","type":"codeVoice"},{"type":"text","text":" and "},{"code":"lockmanInfo","type":"codeVoice"},{"type":"text","text":" implementations:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"ðŸš« "},{"type":"strong","inlineContent":[{"type":"text","text":"Before:"}]}]},{"type":"codeListing","syntax":"swift","code":["@LockmanDynamicCondition","enum ViewAction {","  case makePayment(amount: Double)","  ","  var lockmanInfo: LockmanDynamicConditionInfo {","    switch self {","    case .makePayment(let amount):","      return LockmanDynamicConditionInfo(","        actionId: actionName,","        condition: {","          \/\/ Condition logic was isolated here","          return .success","        }","      )","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"âœ… "},{"inlineContent":[{"type":"text","text":"After:"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Simple enum - no macro needed","enum ViewAction {","  case makePayment(amount: Double)","}"]},{"type":"heading","level":3,"text":"Step 2: Choose your condition evaluation level","anchor":"Step-2-Choose-your-condition-evaluation-level"},{"type":"heading","level":4,"text":"Option A: Reducer-level conditions (Recommended for global constraints)","anchor":"Option-A-Reducer-level-conditions-Recommended-for-global-constraints"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For conditions that apply to multiple actions or need to be checked automatically:"}]},{"type":"codeListing","syntax":"swift","code":["var body: some ReducerOf<Self> {","  Reduce { state, action in","    \/\/ Your reducer logic","    switch action {","    case .makePayment(let amount):","      state.balance -= amount","      return .run { send in","        await send(.paymentCompleted)","      }","    default:","      return .none","    }","  }","  .lock(","    condition: { state, action in","      \/\/ Automatic condition evaluation for all actions","      switch action {","      case .makePayment(let amount):","        guard state.isAuthenticated else {","          return .cancel(AuthError.notAuthenticated)","        }","        guard state.balance >= amount else {","          return .cancel(PaymentError.insufficientFunds)","        }","        return .success","      default:","        return .success","      }","    },","    boundaryId: CancelID.payment,","    lockFailure: { error, send in","      await send(.showError(error.localizedDescription))","    }","  )","}"]},{"type":"heading","level":4,"text":"Option B: Action-level conditions (For specific operations)","anchor":"Option-B-Action-level-conditions-For-specific-operations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For conditions that apply to specific operations only:"}]},{"type":"codeListing","syntax":"swift","code":["let reducer = LockmanDynamicConditionReducer<State, Action>(","  { state, action in","    \/\/ Base reducer logic","    switch action {","    case .makePayment(let amount):","      return .run { send in","        await processPayment(amount)","        await send(.paymentCompleted)","      }","    default:","      return .none","    }","  },","  condition: { _, _ in .success },  \/\/ Allow all at reducer level","  boundaryId: CancelID.operations",")","","\/\/ Use action-level lock for specific conditions","func handlePayment(amount: Double, state: State) -> Effect<Action> {","  return reducer.lock(","    state: state,","    action: .makePayment(amount),","    operation: { send in","      await processPayment(amount)","      await send(.paymentCompleted)","    },","    lockFailure: { error, send in","      await send(.showError(error.localizedDescription))","    },","    boundaryId: CancelID.payment,","    lockCondition: { state, _ in","      \/\/ Specific condition for this operation","      guard state.balance >= amount else {","        return .cancel(PaymentError.insufficientFunds)","      }","      return .success","    }","  )","}"]},{"type":"heading","level":3,"text":"Step 3: Update strategy registration","anchor":"Step-3-Update-strategy-registration"},{"type":"paragraph","inlineContent":[{"text":"Remove ","type":"text"},{"type":"codeVoice","code":"LockmanDynamicConditionStrategy"},{"text":" registration:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"ðŸš« "},{"inlineContent":[{"type":"text","text":"Before:"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["try LockmanManager.container.register(LockmanDynamicConditionStrategy.shared)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"âœ… "},{"type":"strong","inlineContent":[{"text":"After:","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ No registration needed - conditions are evaluated directly in reducers"]},{"type":"heading","level":3,"text":"Step 4: Update error handling","anchor":"Step-4-Update-error-handling"},{"type":"paragraph","inlineContent":[{"text":"Error handling is now done through the ","type":"text"},{"type":"codeVoice","code":"lockFailure"},{"text":" parameter:","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"ðŸš« ","type":"text"},{"inlineContent":[{"text":"Before:","type":"text"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Error handling was done in strategy","condition: {","  guard someCondition else {","    \/\/ Error handling was complex","    return .cancel(error)","  }","  return .success","}"]},{"type":"paragraph","inlineContent":[{"text":"âœ… ","type":"text"},{"type":"strong","inlineContent":[{"text":"After:","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":[".lock(","  condition: { state, action in","    guard someCondition else {","      return .cancel(MyError.conditionFailed)","    }","    return .success","  },","  boundaryId: CancelID.operations,","  lockFailure: { error, send in","    \/\/ Clean error handling","    await send(.showError(error.localizedDescription))","  }",")"]},{"type":"heading","level":2,"text":"Complete migration example","anchor":"Complete-migration-example"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Hereâ€™s a complete before\/after example:"}]},{"type":"heading","level":3,"text":"Before (1.4)","anchor":"Before-14"},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct PaymentFeature {","  @ObservableState","  struct State {","    var balance: Double = 1000","    var isAuthenticated: Bool = true","  }","  ","  @LockmanDynamicCondition","  enum Action {","    case makePayment(amount: Double)","    case paymentCompleted","    ","    var lockmanInfo: LockmanDynamicConditionInfo {","      switch self {","      case .makePayment(let amount):","        return LockmanDynamicConditionInfo(","          actionId: actionName,","          condition: {","            \/\/ Isolated condition logic","            return .success","          }","        )","      default:","        return LockmanDynamicConditionInfo(actionId: actionName)","      }","    }","  }","  ","  var body: some ReducerOf<Self> {","    Reduce { state, action in","      switch action {","      case .makePayment(let amount):","        \/\/ Manual condition checking","        guard state.isAuthenticated else {","          return .none","        }","        guard state.balance >= amount else {","          return .none","        }","        ","        state.balance -= amount","        return .run { send in","          await send(.paymentCompleted)","        }","      case .paymentCompleted:","        return .none","      }","    }","    .lock(boundaryId: CancelID.payment, for: \\.self)","  }","}"]},{"type":"heading","level":3,"text":"After (1.5)","anchor":"After-15"},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct PaymentFeature {","  @ObservableState","  struct State {","    var balance: Double = 1000","    var isAuthenticated: Bool = true","  }","  ","  enum Action {","    case makePayment(amount: Double)","    case paymentCompleted","  }","  ","  var body: some ReducerOf<Self> {","    Reduce { state, action in","      switch action {","      case .makePayment(let amount):","        state.balance -= amount","        return .run { send in","          await send(.paymentCompleted)","        }","      case .paymentCompleted:","        return .none","      }","    }","    .lock(","      condition: { state, action in","        switch action {","        case .makePayment(let amount):","          guard state.isAuthenticated else {","            return .cancel(AuthError.notAuthenticated)","          }","          guard state.balance >= amount else {","            return .cancel(PaymentError.insufficientFunds)","          }","          return .success","        default:","          return .success","        }","      },","      boundaryId: CancelID.payment,","      lockFailure: { error, send in","        await send(.showError(error.localizedDescription))","      }","    )","  }","}"]},{"type":"heading","level":2,"text":"Benefits of upgrading","anchor":"Benefits-of-upgrading"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Simplified architecture"}],"type":"strong"},{"text":": No more complex strategy registration and macro usage","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Better separation of concerns"}]},{"type":"text","text":": Clear distinction between reducer-level and action-level conditions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Improved readability","type":"text"}],"type":"strong"},{"text":": Condition logic is co-located with reducer logic","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Enhanced flexibility","type":"text"}],"type":"strong"},{"type":"text","text":": Mix reducer-level and action-level conditions as needed"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Better testability","type":"text"}]},{"text":": Easier to test condition logic directly in reducers","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Reduced boilerplate","type":"text"}],"type":"strong"},{"type":"text","text":": No macro setup or protocol conformance required"}]}]}]},{"type":"heading","level":2,"text":"Common migration patterns","anchor":"Common-migration-patterns"},{"type":"heading","level":3,"text":"Pattern 1: Authentication + Operation-specific checks","anchor":"Pattern-1-Authentication-+-Operation-specific-checks"},{"type":"codeListing","syntax":"swift","code":["\/\/ Reducer-level: Authentication","\/\/ Action-level: Operation-specific validation",".lock(","  condition: { state, action in","    switch action {","    case .makePayment, .withdraw, .transfer:","      return state.isAuthenticated ? .success : .cancel(AuthError.notAuthenticated)","    default:","      return .success","    }","  },","  boundaryId: CancelID.auth",")","","\/\/ Then use action-level locks for specific checks","reducer.lock(","  \/\/ ... operation-specific condition","  lockCondition: { state, action in","    \/\/ Specific validation","  }",")"]},{"type":"heading","level":3,"text":"Pattern 2: Time-based + Amount-based validation","anchor":"Pattern-2-Time-based-+-Amount-based-validation"},{"type":"codeListing","syntax":"swift","code":[".lock(","  condition: { state, action in","    switch action {","    case .makeTransaction:","      \/\/ Time-based check","      let currentHour = Calendar.current.component(.hour, from: Date())","      guard (9...17).contains(currentHour) else {","        return .cancel(BusinessError.outsideBusinessHours)","      }","      ","      \/\/ Amount-based check","      if case .makeTransaction(let amount) = action {","        guard amount <= state.dailyLimit else {","          return .cancel(BusinessError.dailyLimitExceeded)","        }","      }","      ","      return .success","    default:","      return .success","    }","  },","  boundaryId: CancelID.businessRules",")"]},{"anchor":"Summary","text":"Summary","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Lockman 1.5 represents a major architectural improvement that simplifies dynamic condition evaluation while maintaining all the flexibility of the previous approach. The new unified API provides better separation of concerns, improved testability, and reduced boilerplate code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The migration requires updating your condition logic from strategy-based to reducer-based, but the result is a cleaner, more maintainable codebase with the same powerful exclusive control capabilities."}]}],"kind":"content"}],"references":{"doc://Lockman/documentation/Lockman":{"url":"\/documentation\/lockman","kind":"symbol","identifier":"doc:\/\/Lockman\/documentation\/Lockman","abstract":[{"text":"Elegant exclusive control for user actions in The Composable Architecture applications.","type":"text"}],"role":"collection","title":"Lockman","type":"topic"}}}