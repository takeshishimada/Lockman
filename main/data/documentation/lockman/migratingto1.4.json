{"variants":[{"paths":["\/documentation\/lockman\/migratingto1.4"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"modules":[{"name":"Lockman"}],"role":"article","roleHeading":"Article","title":"Migrating to 1.4"},"abstract":[{"type":"text","text":"Update your code from Lockman 1.3 to take advantage of Lockman 1.4â€™s improved API semantics and enhanced reliability."}],"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"article","hierarchy":{"paths":[["doc:\/\/Lockman\/documentation\/Lockman"]]},"identifier":{"url":"doc:\/\/Lockman\/documentation\/Lockman\/MigratingTo1.4","interfaceLanguage":"swift"},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Lockman 1.4 introduces significant improvements to the ","type":"text"},{"code":"LockmanState","type":"codeVoice"},{"text":" API with more semantic method names and better safety guarantees. The key focus of this release is improving code readability and eliminating potential confusion around method naming while maintaining all existing functionality.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The key improvements include:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Semantic method names"}],"type":"strong"},{"text":": More descriptive and self-documenting method names","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Consistent parameter labels","type":"text"}]},{"type":"text","text":": Unified use of "},{"type":"codeVoice","code":"in:"},{"type":"text","text":" and "},{"type":"codeVoice","code":"matching:"},{"type":"text","text":" throughout the API"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Enhanced safety"}]},{"type":"text","text":": Improved CompositeStrategy reliability and nested action evaluation"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Better organization"}]},{"type":"text","text":": Cleaner Core directory structure"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Eliminated redundancy","type":"text"}]},{"type":"text","text":": Removed duplicate convenience methods that could cause issues"}],"type":"paragraph"}]}]},{"type":"heading","level":2,"text":"Updating dependencies","anchor":"Updating-dependencies"},{"type":"paragraph","inlineContent":[{"text":"To upgrade to Lockman 1.4, update your ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"text":" file:","type":"text"}]},{"type":"codeListing","code":["dependencies: [","  .package(","    url: \"https:\/\/github.com\/takeshishimada\/Lockman\",","    from: \"1.4.0\"","  )","]"],"syntax":"swift"},{"type":"heading","level":2,"text":"Breaking changes","anchor":"Breaking-changes"},{"type":"heading","level":3,"text":"LockmanState method name changes","anchor":"LockmanState-method-name-changes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All "},{"type":"codeVoice","code":"LockmanState"},{"type":"text","text":" query methods have been renamed with more semantic alternatives. This is the primary breaking change in 1.4."}]},{"type":"heading","level":4,"text":"Core Query Methods","anchor":"Core-Query-Methods"},{"header":"row","type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Old Method (1.3)"}]}],[{"type":"paragraph","inlineContent":[{"text":"New Method (1.4)","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"currents(boundaryId:)"}]}],[{"type":"paragraph","inlineContent":[{"code":"currentLocks(in:)","type":"codeVoice"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"currents(boundaryId:key:)"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"currentLocks(in:matching:)"}]}]],[[{"type":"paragraph","inlineContent":[{"code":"contains(boundaryId:key:)","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"code":"hasActiveLocks(in:matching:)","type":"codeVoice"}]}]],[[{"type":"paragraph","inlineContent":[{"code":"count(boundaryId:key:)","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"code":"activeLockCount(in:matching:)","type":"codeVoice"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"keys(boundaryId:)"}]}],[{"type":"paragraph","inlineContent":[{"code":"activeKeys(in:)","type":"codeVoice"}]}]]]},{"text":"State Query Methods","anchor":"State-Query-Methods","type":"heading","level":4},{"header":"row","type":"table","rows":[[[{"inlineContent":[{"type":"text","text":"Old Method (1.3)"}],"type":"paragraph"}],[{"inlineContent":[{"text":"New Method (1.4)","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"allBoundaryIds()"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"activeBoundaryIds()"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"totalLockCount()"}],"type":"paragraph"}],[{"inlineContent":[{"code":"totalActiveLockCount()","type":"codeVoice"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"codeVoice","code":"getAllLocks()"}],"type":"paragraph"}],[{"inlineContent":[{"code":"allActiveLocks()","type":"codeVoice"}],"type":"paragraph"}]]]},{"text":"ActionId-Specific Methods","anchor":"ActionId-Specific-Methods","type":"heading","level":4},{"header":"row","type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Old Method (1.3)"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"New Method (1.4)"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"removeAll(boundaryId:actionId:)"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"removeAllLocks(in:matching:)"}]}]]]},{"text":"Parameter label changes","anchor":"Parameter-label-changes","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"All methods now use consistent parameter labeling:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Boundary parameters use "},{"type":"codeVoice","code":"in:"},{"type":"text","text":" label"}]}]},{"content":[{"inlineContent":[{"text":"Key\/ActionId parameters use ","type":"text"},{"code":"matching:","type":"codeVoice"},{"text":" label","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"ðŸš« "},{"type":"strong","inlineContent":[{"type":"text","text":"Before (1.3):"}]}],"type":"paragraph"},{"code":["let locks = state.currents(boundaryId: .userActions)","let hasLock = state.contains(boundaryId: .userActions, key: \"login\")","let count = state.count(boundaryId: .userActions, key: \"login\")"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"âœ… "},{"type":"strong","inlineContent":[{"text":"After (1.4):","type":"text"}]}],"type":"paragraph"},{"code":["let locks = state.currentLocks(in: .userActions)","let hasLock = state.hasActiveLocks(in: .userActions, matching: \"login\")","let count = state.activeLockCount(in: .userActions, matching: \"login\")"],"syntax":"swift","type":"codeListing"},{"text":"Migration guide","anchor":"Migration-guide","type":"heading","level":2},{"text":"Step 1: Update method names in custom strategies","anchor":"Step-1-Update-method-names-in-custom-strategies","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"If you have custom strategies that interact with "},{"type":"codeVoice","code":"LockmanState"},{"type":"text","text":", update all method calls:"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"ðŸš« "},{"type":"strong","inlineContent":[{"type":"text","text":"Before (1.3):"}]}],"type":"paragraph"},{"code":["class CustomStrategy: LockmanStrategy {","  func evaluate(action: LockmanAction, state: LockmanState) -> LockmanResult {","    let currentCount = state.count(boundaryId: action.boundaryId, key: action.key)","    let allBoundaries = state.allBoundaryIds()","    ","    if state.contains(boundaryId: action.boundaryId, key: action.key) {","      return .cancel(...)","    }","    ","    return .success","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"âœ… ","type":"text"},{"inlineContent":[{"text":"After (1.4):","type":"text"}],"type":"strong"}],"type":"paragraph"},{"code":["class CustomStrategy: LockmanStrategy {","  func evaluate(action: LockmanAction, state: LockmanState) -> LockmanResult {","    let currentCount = state.activeLockCount(in: action.boundaryId, matching: action.key)","    let allBoundaries = state.activeBoundaryIds()","    ","    if state.hasActiveLocks(in: action.boundaryId, matching: action.key) {","      return .cancel(...)","    }","    ","    return .success","  }","}"],"syntax":"swift","type":"codeListing"},{"text":"Step 2: Update test code","anchor":"Step-2-Update-test-code","type":"heading","level":3},{"inlineContent":[{"text":"Update any test code that directly interacts with ","type":"text"},{"code":"LockmanState","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"ðŸš« "},{"inlineContent":[{"text":"Before (1.3):","type":"text"}],"type":"strong"}],"type":"paragraph"},{"code":["func testLockState() {","  let state = LockmanState()","  \/\/ ... add some locks","  ","  XCTAssertEqual(state.totalLockCount(), 2)","  XCTAssertTrue(state.contains(boundaryId: .test, key: \"action1\"))","  ","  let currentLocks = state.currents(boundaryId: .test)","  XCTAssertEqual(currentLocks.count, 1)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"âœ… "},{"type":"strong","inlineContent":[{"text":"After (1.4):","type":"text"}]}],"type":"paragraph"},{"code":["func testLockState() {","  let state = LockmanState()","  \/\/ ... add some locks","  ","  XCTAssertEqual(state.totalActiveLockCount(), 2)","  XCTAssertTrue(state.hasActiveLocks(in: .test, matching: \"action1\"))","  ","  let currentLocks = state.currentLocks(in: .test)","  XCTAssertEqual(currentLocks.count, 1)","}"],"syntax":"swift","type":"codeListing"},{"text":"Step 3: Update debugging and monitoring code","anchor":"Step-3-Update-debugging-and-monitoring-code","type":"heading","level":3},{"inlineContent":[{"text":"If you have code that monitors lock state for debugging or analytics:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"ðŸš« ","type":"text"},{"inlineContent":[{"type":"text","text":"Before (1.3):"}],"type":"strong"}],"type":"paragraph"},{"code":["func debugLockState(_ state: LockmanState) {","  print(\"Total locks: \\(state.totalLockCount())\")","  ","  for boundaryId in state.allBoundaryIds() {","    let locks = state.currents(boundaryId: boundaryId)","    let keys = state.keys(boundaryId: boundaryId)","    print(\"Boundary \\(boundaryId): \\(locks.count) locks, keys: \\(keys)\")","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"âœ… "},{"type":"strong","inlineContent":[{"text":"After (1.4):","type":"text"}]}],"type":"paragraph"},{"code":["func debugLockState(_ state: LockmanState) {","  print(\"Total locks: \\(state.totalActiveLockCount())\")","  ","  for boundaryId in state.activeBoundaryIds() {","    let locks = state.currentLocks(in: boundaryId)","    let keys = state.activeKeys(in: boundaryId)","    print(\"Boundary \\(boundaryId): \\(locks.count) locks, keys: \\(keys)\")","  }","}"],"syntax":"swift","type":"codeListing"},{"text":"Non-breaking improvements","anchor":"Non-breaking-improvements","type":"heading","level":2},{"text":"Enhanced CompositeStrategy reliability","anchor":"Enhanced-CompositeStrategy-reliability","type":"heading","level":3},{"inlineContent":[{"text":"Version 1.4 includes critical fixes to ","type":"text"},{"type":"codeVoice","code":"CompositeStrategy"},{"text":" that improve reliability without requiring code changes:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Fixed critical logic error in "},{"type":"codeVoice","code":"coordinateResults"},{"type":"text","text":" method"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Simplified result coordination logic"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Enhanced safety in concurrent operations"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Improved nested action evaluation","anchor":"Improved-nested-action-evaluation","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Reducer.lock()"},{"type":"text","text":" method now properly prioritizes nested action evaluation over root actions, providing more predictable behavior in complex reducer hierarchies."}],"type":"paragraph"},{"text":"Better Core directory organization","anchor":"Better-Core-directory-organization","type":"heading","level":3},{"inlineContent":[{"text":"The Core directory structure has been reorganized for better maintainability:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Error types moved to "},{"type":"codeVoice","code":"Core\/Errors\/"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Protocol definitions moved to ","type":"text"},{"code":"Core\/Protocols\/","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Core types moved to appropriate locations"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"This change doesnâ€™t affect public APIs but improves internal organization."}],"type":"paragraph"},{"text":"Complete migration examples","anchor":"Complete-migration-examples","type":"heading","level":2},{"text":"Custom Strategy Migration","anchor":"Custom-Strategy-Migration","type":"heading","level":3},{"inlineContent":[{"text":"ðŸš« ","type":"text"},{"type":"strong","inlineContent":[{"text":"Before (1.3):","type":"text"}]}],"type":"paragraph"},{"code":["struct ValidationStrategy: LockmanStrategy {","  func evaluate(action: LockmanAction, state: LockmanState) -> LockmanResult {","    \/\/ Check if user has too many active operations","    let userBoundary = BoundaryId.user(action.userId)","    let activeOperations = state.count(boundaryId: userBoundary, key: \"operation\")","    ","    if activeOperations >= maxConcurrentOperations {","      return .cancel(TooManyOperationsError())","    }","    ","    \/\/ Check global system load","    let totalSystemLoad = state.totalLockCount()","    if totalSystemLoad > systemCapacity {","      return .cancel(SystemOverloadError())","    }","    ","    return .success","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"âœ… ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"After (1.4):"}]}],"type":"paragraph"},{"code":["struct ValidationStrategy: LockmanStrategy {","  func evaluate(action: LockmanAction, state: LockmanState) -> LockmanResult {","    \/\/ Check if user has too many active operations","    let userBoundary = BoundaryId.user(action.userId)","    let activeOperations = state.activeLockCount(in: userBoundary, matching: \"operation\")","    ","    if activeOperations >= maxConcurrentOperations {","      return .cancel(TooManyOperationsError())","    }","    ","    \/\/ Check global system load","    let totalSystemLoad = state.totalActiveLockCount()","    if totalSystemLoad > systemCapacity {","      return .cancel(SystemOverloadError())","    }","    ","    return .success","  }","}"],"syntax":"swift","type":"codeListing"},{"text":"Test Code Migration","anchor":"Test-Code-Migration","type":"heading","level":3},{"inlineContent":[{"text":"ðŸš« ","type":"text"},{"inlineContent":[{"type":"text","text":"Before (1.3):"}],"type":"strong"}],"type":"paragraph"},{"code":["func testConcurrentUserActions() {","  let state = LockmanState()","  ","  \/\/ Simulate some active locks","  state.addLock(boundaryId: .userActions, key: \"login\", actionId: \"action1\")","  state.addLock(boundaryId: .userActions, key: \"logout\", actionId: \"action2\")","  ","  \/\/ Verify state","  XCTAssertEqual(state.totalLockCount(), 2)","  XCTAssertTrue(state.contains(boundaryId: .userActions, key: \"login\"))","  XCTAssertFalse(state.contains(boundaryId: .userActions, key: \"register\"))","  ","  let allKeys = state.keys(boundaryId: .userActions)","  XCTAssertEqual(Set(allKeys), Set([\"login\", \"logout\"]))","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"âœ… "},{"type":"strong","inlineContent":[{"type":"text","text":"After (1.4):"}]}],"type":"paragraph"},{"code":["func testConcurrentUserActions() {","  let state = LockmanState()","  ","  \/\/ Simulate some active locks","  state.addLock(boundaryId: .userActions, key: \"login\", actionId: \"action1\")","  state.addLock(boundaryId: .userActions, key: \"logout\", actionId: \"action2\")","  ","  \/\/ Verify state","  XCTAssertEqual(state.totalActiveLockCount(), 2)","  XCTAssertTrue(state.hasActiveLocks(in: .userActions, matching: \"login\"))","  XCTAssertFalse(state.hasActiveLocks(in: .userActions, matching: \"register\"))","  ","  let allKeys = state.activeKeys(in: .userActions)","  XCTAssertEqual(Set(allKeys), Set([\"login\", \"logout\"]))","}"],"syntax":"swift","type":"codeListing"},{"text":"Benefits of upgrading","anchor":"Benefits-of-upgrading","type":"heading","level":2},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Improved readability"}],"type":"strong"},{"text":": Method names are more descriptive and self-documenting","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Consistent API","type":"text"}]},{"type":"text","text":": Unified parameter labeling throughout the LockmanState API"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Enhanced reliability","type":"text"}],"type":"strong"},{"type":"text","text":": Critical fixes to CompositeStrategy and nested action evaluation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Better maintenance","type":"text"}]},{"text":": Cleaner code organization and reduced redundancy","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Future-proof"}],"type":"strong"},{"text":": Sets foundation for continued API evolution","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"text":"Migration checklist","anchor":"Migration-checklist","type":"heading","level":2},{"items":[{"checked":false,"content":[{"inlineContent":[{"type":"text","text":"Update "},{"type":"codeVoice","code":"Package.swift"},{"type":"text","text":" dependency to 1.4.0"}],"type":"paragraph"}]},{"checked":false,"content":[{"inlineContent":[{"text":"Search codebase for old ","type":"text"},{"type":"codeVoice","code":"LockmanState"},{"text":" method names","type":"text"}],"type":"paragraph"}]},{"checked":false,"content":[{"inlineContent":[{"type":"text","text":"Replace method calls using the mapping table above"}],"type":"paragraph"}]},{"checked":false,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Update parameter labels to use "},{"type":"codeVoice","code":"in:"},{"type":"text","text":" and "},{"type":"codeVoice","code":"matching:"}]}]},{"checked":false,"content":[{"inlineContent":[{"text":"Run tests to verify migration success","type":"text"}],"type":"paragraph"}]},{"checked":false,"content":[{"inlineContent":[{"text":"Update any documentation referencing old method names","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"API mapping reference","anchor":"API-mapping-reference","type":"heading","level":2},{"text":"Quick Reference Table","anchor":"Quick-Reference-Table","type":"heading","level":3},{"header":"row","type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Old API Pattern"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"New API Pattern"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".currents(boundaryId: X)"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".currentLocks(in: X)"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".currents(boundaryId: X, key: Y)"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".currentLocks(in: X, matching: Y)"}]}]],[[{"type":"paragraph","inlineContent":[{"code":".contains(boundaryId: X, key: Y)","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"code":".hasActiveLocks(in: X, matching: Y)","type":"codeVoice"}]}]],[[{"type":"paragraph","inlineContent":[{"code":".count(boundaryId: X, key: Y)","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".activeLockCount(in: X, matching: Y)"}]}]],[[{"type":"paragraph","inlineContent":[{"code":".keys(boundaryId: X)","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"code":".activeKeys(in: X)","type":"codeVoice"}]}]],[[{"type":"paragraph","inlineContent":[{"code":".allBoundaryIds()","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"code":".activeBoundaryIds()","type":"codeVoice"}]}]],[[{"type":"paragraph","inlineContent":[{"code":".totalLockCount()","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".totalActiveLockCount()"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".getAllLocks()"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".allActiveLocks()"}]}]]]},{"text":"Testing your migration","anchor":"Testing-your-migration","type":"heading","level":2},{"inlineContent":[{"text":"After migrating, verify that:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"All compilation errors are resolved","type":"text"}]},{"type":"text","text":": Check that method names and parameter labels are correct"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Existing functionality is maintained"}],"type":"strong"},{"text":": Run your test suite to ensure behavior is unchanged","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Custom strategies work correctly"}],"type":"strong"},{"text":": Test any custom strategy implementations","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Performance is maintained","type":"text"}],"type":"strong"},{"text":": Verify no performance regression from the changes","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"text":"Summary","anchor":"Summary","type":"heading","level":2},{"inlineContent":[{"text":"Lockman 1.4 focuses on improving API semantics and reliability while maintaining full backward compatibility for the core locking functionality. The primary change involves updating ","type":"text"},{"code":"LockmanState","type":"codeVoice"},{"text":" method names to be more descriptive and consistent.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Key takeaways:","type":"text"}]}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Method name changes","type":"text"}]},{"type":"text","text":": All "},{"type":"codeVoice","code":"LockmanState"},{"type":"text","text":" query methods have semantic replacements"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Consistent parameters","type":"text"}]},{"text":": Unified use of ","type":"text"},{"type":"codeVoice","code":"in:"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"matching:"},{"text":" parameter labels","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Enhanced reliability"}],"type":"strong"},{"type":"text","text":": Critical fixes for CompositeStrategy and nested action evaluation"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"No functional changes"}],"type":"strong"},{"text":": All existing locking behavior is preserved","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"The migration is straightforward and primarily involves renaming method calls. The new API provides better self-documentation and sets a strong foundation for future enhancements.","type":"text"}],"type":"paragraph"}]}],"references":{"doc://Lockman/documentation/Lockman":{"url":"\/documentation\/lockman","kind":"symbol","identifier":"doc:\/\/Lockman\/documentation\/Lockman","abstract":[{"text":"Elegant exclusive control for user actions in The Composable Architecture applications.","type":"text"}],"role":"collection","title":"Lockman","type":"topic"}}}