{"hierarchy":{"paths":[["doc:\/\/Lockman\/documentation\/Lockman"]]},"metadata":{"modules":[{"name":"Lockman"}],"roleHeading":"Article","role":"article","title":"Migrating to 1.2"},"abstract":[{"text":"Update your code from Lockman 1.1 to take advantage of Lockman 1.2‚Äôs automatic cancellation ID management and enhanced safety features.","type":"text"}],"primaryContentSections":[{"content":[{"text":"Overview","type":"heading","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"text":"Lockman 1.2 introduces a major developer experience improvement by automatically handling cancellation IDs for all Effect.lock operations. This eliminates the need to manually specify ","type":"text"},{"type":"codeVoice","code":".cancellable(id: boundaryId)"},{"text":" when using ","type":"text"},{"type":"codeVoice","code":".run()"},{"text":" methods with Lockman‚Äôs lock functionality, resulting in cleaner, more maintainable code.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The key improvements include:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Automatic cancellation ID management for all Effect.lock methods","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"‚ÄúGuaranteed Resource Cleanup‚Äù design principle implementation"}]}]},{"content":[{"inlineContent":[{"text":"Enhanced safety with improved cancellation scope control","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Comprehensive documentation with before\/after examples","type":"text"}]}]}]},{"text":"Updating dependencies","type":"heading","anchor":"Updating-dependencies","level":2},{"type":"paragraph","inlineContent":[{"text":"To upgrade to Lockman 1.2, update your ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"text":" file:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","  .package(","    url: \"https:\/\/github.com\/takeshishimada\/Lockman\",","    from: \"1.2.0\"","  )","]"]},{"text":"Non-breaking changes","type":"heading","anchor":"Non-breaking-changes","level":2},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Important:"}],"type":"strong"},{"text":" Lockman 1.2 is ","type":"text"},{"inlineContent":[{"text":"100% backward compatible","type":"text"}],"type":"strong"},{"text":". All existing code will continue to work without any modifications. However, you can now simplify your code significantly by removing manual cancellation ID specifications.","type":"text"}]},{"text":"Major improvements","type":"heading","anchor":"Major-improvements","level":2},{"text":"Automatic cancellation ID management","type":"heading","anchor":"Automatic-cancellation-ID-management","level":3},{"type":"paragraph","inlineContent":[{"text":"All Effect.lock methods now automatically apply ","type":"text"},{"code":".cancellable(id: boundaryId)","type":"codeVoice"},{"text":" to operations, eliminating the need for manual specification.","type":"text"}]},{"text":"Enhanced cancellation scope control","type":"heading","anchor":"Enhanced-cancellation-scope-control","level":3},{"type":"paragraph","inlineContent":[{"text":"The ‚ÄúGuaranteed Resource Cleanup‚Äù principle ensures that:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Operations are cancellable","type":"text"}]},{"text":": Business logic can be cancelled using the boundaryId","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Resource cleanup is guaranteed","type":"text"}]},{"type":"text","text":": Lock release always executes regardless of cancellation"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Deadlock prevention","type":"text"}],"type":"strong"},{"text":": Fixed potential deadlock scenarios in concatenated operations","type":"text"}],"type":"paragraph"}]}]},{"text":"Migration opportunities","type":"heading","anchor":"Migration-opportunities","level":2},{"type":"paragraph","inlineContent":[{"text":"While no changes are required, you can simplify your existing code to take advantage of the new automatic cancellation features.","type":"text"}]},{"text":"Method chain style (.lock)","type":"heading","anchor":"Method-chain-style-lock","level":3},{"type":"paragraph","inlineContent":[{"text":"üü° Before (1.1 - still works):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["return .run { send in","  await performAsyncWork()","  await send(.completed)","}",".cancellable(id: boundaryId)  \/\/ Manual specification",".lock(action: action, boundaryId: boundaryId)"]},{"type":"paragraph","inlineContent":[{"text":"‚úÖ After (1.2 - simplified):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["return .run { send in","  await performAsyncWork()","  await send(.completed)","}",".lock(action: action, boundaryId: boundaryId)  \/\/ Automatic application!"]},{"text":"Static method style (.withLock)","type":"heading","anchor":"Static-method-style-withLock","level":3},{"type":"paragraph","inlineContent":[{"text":"üü° Before (1.1 - still works):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["return .withLock(","  operation: { send in","    try await Task.sleep(nanoseconds: 100_000_000)","    await send(.completed)","  },","  action: action,","  boundaryId: CancelID.operation",")","\/\/ Additional .cancellable(id:) was not needed here in 1.1"]},{"type":"paragraph","inlineContent":[{"text":"‚úÖ After (1.2 - enhanced safety):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["return .withLock(","  operation: { send in","    try await Task.sleep(nanoseconds: 100_000_000)","    await send(.completed)","  },","  action: action,","  boundaryId: CancelID.operation",")","\/\/ Now with enhanced \"Guaranteed Resource Cleanup\" safety"]},{"text":"Concatenated operations","type":"heading","anchor":"Concatenated-operations","level":3},{"type":"paragraph","inlineContent":[{"text":"üü° Before (1.1 - potential deadlock risk):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["return .withLock(","  concatenating: [","    .run { send in await send(.stepOne) },","    .run { send in await send(.stepTwo) },","    .run { send in await send(.stepThree) }","  ],","  action: action,","  boundaryId: CancelID.operation",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‚úÖ After (1.2 - deadlock prevention):"}]},{"type":"codeListing","syntax":"swift","code":["return .withLock(","  concatenating: [","    .run { send in await send(.stepOne) },","    .run { send in await send(.stepTwo) },","    .run { send in await send(.stepThree) }","  ],","  action: action,","  boundaryId: CancelID.operation",")","\/\/ Enhanced with proper cancellation scope management"]},{"text":"Manual unlock operations","type":"heading","anchor":"Manual-unlock-operations","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"üü° Before (1.1):"}]},{"type":"codeListing","syntax":"swift","code":["return .withLock(","  operation: { send, unlock in","    defer { unlock() }","    try await performCriticalWork()","    await send(.completed)","  },","  action: action,","  boundaryId: CancelID.operation",")"]},{"type":"paragraph","inlineContent":[{"text":"‚úÖ After (1.2 - with automatic cancellation):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["return .withLock(","  operation: { send, unlock in","    defer { unlock() }","    try await performCriticalWork()","    await send(.completed)","  },","  action: action,","  boundaryId: CancelID.operation",")","\/\/ Now includes automatic cancellation ID management"]},{"text":"Code cleanup recommendations","type":"heading","anchor":"Code-cleanup-recommendations","level":2},{"text":"Remove redundant .cancellable(id:) calls","type":"heading","anchor":"Remove-redundant-cancellableid-calls","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now remove manual "},{"type":"codeVoice","code":".cancellable(id:)"},{"type":"text","text":" specifications when using "},{"type":"codeVoice","code":".lock()"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"text":"üü° Before (can be simplified):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct MyFeature {","  \/\/ ... state and action definitions ...","  ","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .fetchData:","        return .run { send in","          let data = try await apiClient.fetchData()","          await send(.dataReceived(data))","        }","        .cancellable(id: CancelID.fetch)  \/\/ ‚Üê Remove this line","        .lock(action: action, boundaryId: CancelID.fetch)","        ","      case .dataReceived(let data):","        state.data = data","        return .none","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"‚úÖ After (simplified):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct MyFeature {","  \/\/ ... state and action definitions ...","  ","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .fetchData:","        return .run { send in","          let data = try await apiClient.fetchData()","          await send(.dataReceived(data))","        }","        .lock(action: action, boundaryId: CancelID.fetch)  \/\/ Automatic cancellation!","        ","      case .dataReceived(let data):","        state.data = data","        return .none","      }","    }","  }","}"]},{"text":"Simplify complex effect chains","type":"heading","anchor":"Simplify-complex-effect-chains","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"üü° Before (verbose):"}]},{"type":"codeListing","syntax":"swift","code":["return .merge(","  .run { send in","    await send(.started)","  },","  .run { send in","    try await performWork()","    await send(.workCompleted)","  }","  .cancellable(id: boundaryId)  \/\/ ‚Üê Remove this","  .lock(action: action, boundaryId: boundaryId),","  ","  .run { send in","    await send(.monitoring)","  }",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‚úÖ After (clean):"}]},{"type":"codeListing","syntax":"swift","code":["return .merge(","  .run { send in","    await send(.started)","  },","  .run { send in","    try await performWork()","    await send(.workCompleted)","  }","  .lock(action: action, boundaryId: boundaryId),  \/\/ Clean and automatic!","  ","  .run { send in","    await send(.monitoring)","  }",")"]},{"text":"Enhanced safety features","type":"heading","anchor":"Enhanced-safety-features","level":2},{"text":"Guaranteed resource cleanup","type":"heading","anchor":"Guaranteed-resource-cleanup","level":3},{"type":"paragraph","inlineContent":[{"text":"Lockman 1.2 implements the ‚ÄúGuaranteed Resource Cleanup‚Äù principle:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ This operation can be cancelled, but the unlock will ALWAYS execute","return .withLock(","  operation: { send in","    try await riskyOperation()  \/\/ ‚Üê Can be cancelled","    await send(.completed)","  },","  action: action,","  boundaryId: CancelID.operation",")","\/\/ unlock() is guaranteed to execute even if operation is cancelled"]},{"text":"Improved concatenated operations","type":"heading","anchor":"Improved-concatenated-operations","level":3},{"type":"paragraph","inlineContent":[{"text":"Concatenated operations now have safer cancellation scope management:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["return .withLock(","  concatenating: [","    .run { send in await step1(send) },    \/\/ ‚Üê These operations are cancellable","    .run { send in await step2(send) },    \/\/ ‚Üê as a group","    .run { send in await step3(send) }     \/\/ ‚Üê ","  ],","  action: action,","  boundaryId: CancelID.workflow",")","\/\/ The unlock effect is NOT cancellable - guaranteed cleanup"]},{"text":"Benefits of upgrading","type":"heading","anchor":"Benefits-of-upgrading","level":2},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Cleaner code","type":"text"}]},{"type":"text","text":": Remove boilerplate "},{"type":"codeVoice","code":".cancellable(id:)"},{"type":"text","text":" calls"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Enhanced safety","type":"text"}]},{"type":"text","text":": ‚ÄúGuaranteed Resource Cleanup‚Äù prevents resource leaks"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Deadlock prevention"}]},{"type":"text","text":": Improved cancellation scope management"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Better maintainability"}]},{"type":"text","text":": Less manual cancellation ID management"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Improved developer experience"}]},{"text":": More intuitive API usage","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Zero performance impact"}]},{"text":": Automatic features add no runtime overhead","type":"text"}],"type":"paragraph"}]}]},{"text":"Testing your migration","type":"heading","anchor":"Testing-your-migration","level":2},{"type":"paragraph","inlineContent":[{"text":"After removing manual ","type":"text"},{"code":".cancellable(id:)","type":"codeVoice"},{"text":" calls, verify that:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Cancellation still works","type":"text"}],"type":"strong"},{"text":": Test that operations can be properly cancelled","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Resource cleanup","type":"text"}]},{"text":": Ensure locks are properly released","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"No deadlocks","type":"text"}]},{"type":"text","text":": Verify concatenated operations work correctly"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Error handling"}]},{"text":": Check that error handlers still receive proper errors","type":"text"}]}]}]},{"text":"Complete migration example","type":"heading","anchor":"Complete-migration-example","level":2},{"type":"paragraph","inlineContent":[{"text":"Here‚Äôs a complete example showing a typical migration:","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"üü° Before (1.1):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct PaymentFeature {","  struct State: Equatable {","    var isProcessing = false","    var result: PaymentResult?","  }","  ","  @CasePathable","  enum Action: Equatable, LockmanAction {","    case processPayment(amount: Decimal)","    case paymentCompleted(PaymentResult)","    case paymentFailed","    ","    var lockmanInfo: LockmanSingleExecutionInfo {","      .init(actionId: \"payment\", mode: .boundary)","    }","  }","  ","  enum CancelID: LockmanBoundaryId {","    case payment","  }","  ","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .processPayment(let amount):","        state.isProcessing = true","        return .run { send in","          do {","            let result = try await paymentService.process(amount)","            await send(.paymentCompleted(result))","          } catch {","            await send(.paymentFailed)","          }","        }","        .cancellable(id: CancelID.payment)  \/\/ ‚Üê Manual specification","        .lock(action: action, boundaryId: CancelID.payment)","        ","      case .paymentCompleted(let result):","        state.isProcessing = false","        state.result = result","        return .none","        ","      case .paymentFailed:","        state.isProcessing = false","        return .none","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"‚úÖ After (1.2):"}]},{"type":"codeListing","syntax":"swift","code":["@Reducer","struct PaymentFeature {","  struct State: Equatable {","    var isProcessing = false","    var result: PaymentResult?","  }","  ","  @CasePathable","  enum Action: Equatable, LockmanAction {","    case processPayment(amount: Decimal)","    case paymentCompleted(PaymentResult)","    case paymentFailed","    ","    var lockmanInfo: LockmanSingleExecutionInfo {","      .init(actionId: \"payment\", mode: .boundary)","    }","  }","  ","  enum CancelID: LockmanBoundaryId {","    case payment","  }","  ","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .processPayment(let amount):","        state.isProcessing = true","        return .run { send in","          do {","            let result = try await paymentService.process(amount)","            await send(.paymentCompleted(result))","          } catch {","            await send(.paymentFailed)","          }","        }","        .lock(action: action, boundaryId: CancelID.payment)  \/\/ ‚Üê Automatic cancellation!","        ","      case .paymentCompleted(let result):","        state.isProcessing = false","        state.result = result","        return .none","        ","      case .paymentFailed:","        state.isProcessing = false","        return .none","      }","    }","  }","}"]},{"text":"Summary","type":"heading","anchor":"Summary","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Lockman 1.2 represents a significant improvement in developer experience while maintaining complete backward compatibility. The automatic cancellation ID management eliminates boilerplate code and reduces the chance of errors, while the enhanced safety features provide better resource management."}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Key takeaways:","type":"text"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"No breaking changes"}]},{"text":": All existing code continues to work","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Simplification opportunity","type":"text"}]},{"text":": Remove manual ","type":"text"},{"type":"codeVoice","code":".cancellable(id:)"},{"text":" calls where appropriate","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Enhanced safety","type":"text"}]},{"type":"text","text":": Benefit from ‚ÄúGuaranteed Resource Cleanup‚Äù principle"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Better maintainability","type":"text"}]},{"type":"text","text":": Cleaner, more intuitive code patterns"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"The automatic features work transparently, ensuring your application‚Äôs operations are properly managed with improved safety guarantees.","type":"text"}]}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/lockman\/migratingto1.2"]}],"schemaVersion":{"patch":0,"minor":3,"major":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Lockman\/documentation\/Lockman\/MigratingTo1.2"},"kind":"article","sections":[],"references":{"doc://Lockman/documentation/Lockman":{"url":"\/documentation\/lockman","kind":"symbol","identifier":"doc:\/\/Lockman\/documentation\/Lockman","abstract":[{"text":"Elegant exclusive control for user actions in The Composable Architecture applications.","type":"text"}],"role":"collection","title":"Lockman","type":"topic"}}}