{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Lockman\/documentation\/Lockman\/MigratingTo1.1"},"sections":[],"kind":"article","primaryContentSections":[{"content":[{"level":2,"text":"Overview","anchor":"Overview","type":"heading"},{"inlineContent":[{"type":"text","text":"Lockman 1.1 introduces important improvements to prevent resource leaks and provide better type safety for cancellation handling. The main focus is on immediate unlock functionality that ensures locks are released as soon as actions are cancelled, preventing false lock conflicts."}],"type":"paragraph"},{"inlineContent":[{"text":"The key changes include:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"New ","type":"text"},{"type":"codeVoice","code":"LockmanPrecedingCancellationError"},{"text":" protocol for type-safe cancellation handling","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Enhanced ","type":"text"},{"code":"LockmanPriorityBasedError","type":"codeVoice"},{"text":" with complete action information","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Immediate unlock mechanism to prevent resource leaks"}]}]}],"type":"unorderedList"},{"level":2,"text":"Updating dependencies","anchor":"Updating-dependencies","type":"heading"},{"inlineContent":[{"text":"To upgrade to Lockman 1.1, update your ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"text":" file:","type":"text"}],"type":"paragraph"},{"code":["dependencies: [","  .package(","    url: \"https:\/\/github.com\/takeshishimada\/Lockman\",","    from: \"1.1.0\"","  )","]"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Breaking changes","anchor":"Breaking-changes","type":"heading"},{"level":3,"text":"`LockmanResult.successWithPrecedingCancellation` type change","anchor":"LockmanResultsuccessWithPrecedingCancellation-type-change","type":"heading"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"successWithPrecedingCancellation"},{"type":"text","text":" case now requires errors conforming to "},{"type":"codeVoice","code":"LockmanPrecedingCancellationError"},{"type":"text","text":" protocol instead of generic "},{"type":"codeVoice","code":"LockmanError"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"ðŸš« Before (1.0):"}],"type":"paragraph"},{"code":["case successWithPrecedingCancellation(LockmanError)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"âœ… After (1.1):","type":"text"}],"type":"paragraph"},{"code":["case successWithPrecedingCancellation(any LockmanPrecedingCancellationError)"],"syntax":"swift","type":"codeListing"},{"level":3,"text":"`LockmanPriorityBasedError` enhanced with action information","anchor":"LockmanPriorityBasedError-enhanced-with-action-information","type":"heading"},{"inlineContent":[{"type":"text","text":"All "},{"type":"codeVoice","code":"LockmanPriorityBasedError"},{"type":"text","text":" cases now include complete "},{"type":"codeVoice","code":"lockmanInfo"},{"type":"text","text":" and "},{"type":"codeVoice","code":"boundaryId"},{"type":"text","text":" parameters, providing better context about the cancelled action."}],"type":"paragraph"},{"inlineContent":[{"text":"ðŸš« Before (1.0):","type":"text"}],"type":"paragraph"},{"code":["enum LockmanPriorityBasedError: LockmanError {","    case precedingActionCancelled(precedingActionName: String, precedingPriority: LockmanPriority)","    case higherPriorityExists(existingActionName: String, existingPriority: LockmanPriority)","    case samePriorityConflict(existingActionName: String)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"âœ… After (1.1):","type":"text"}],"type":"paragraph"},{"code":["enum LockmanPriorityBasedError: LockmanError {","    case precedingActionCancelled(","        precedingActionName: String,","        precedingPriority: LockmanPriority,","        lockmanInfo: any LockmanInfo,","        boundaryId: any LockmanBoundaryId","    )","    case higherPriorityExists(","        existingActionName: String,","        existingPriority: LockmanPriority,","        lockmanInfo: any LockmanInfo,","        boundaryId: any LockmanBoundaryId","    )","    case samePriorityConflict(","        existingActionName: String,","        lockmanInfo: any LockmanInfo,","        boundaryId: any LockmanBoundaryId","    )","}"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"New features","anchor":"New-features","type":"heading"},{"level":3,"text":"`LockmanPrecedingCancellationError` protocol","anchor":"LockmanPrecedingCancellationError-protocol","type":"heading"},{"inlineContent":[{"type":"text","text":"This new protocol provides a type-safe way to access information about cancelled actions:"}],"type":"paragraph"},{"code":["public protocol LockmanPrecedingCancellationError: LockmanError {","    var lockmanInfo: any LockmanInfo { get }","    var boundaryId: any LockmanBoundaryId { get }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"All strategy cancellation errors now conform to this protocol:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LockmanSingleExecutionCancellationError"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"LockmanPriorityBasedCancellationError","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"code":"LockmanGroupCoordinationCancellationError","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"LockmanDynamicConditionCancellationError","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LockmanConcurrencyLimitedCancellationError"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"LockmanCompositeCancellationError"}]}]}],"type":"unorderedList"},{"level":3,"text":"Immediate unlock functionality","anchor":"Immediate-unlock-functionality","type":"heading"},{"inlineContent":[{"type":"text","text":"Lockman 1.1 automatically releases locks immediately when actions are cancelled, preventing resource leaks and false lock conflicts. This happens transparently without any code changes required."}],"type":"paragraph"},{"level":2,"text":"Migration guide","anchor":"Migration-guide","type":"heading"},{"level":3,"text":"Handling cancellation errors","anchor":"Handling-cancellation-errors","type":"heading"},{"inlineContent":[{"text":"If youâ€™re explicitly handling ","type":"text"},{"code":"successWithPrecedingCancellation","type":"codeVoice"},{"text":" cases, update your code to use the new protocol:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"ðŸš« Before (1.0):"}],"type":"paragraph"},{"code":["switch result {","case .successWithPrecedingCancellation(let error):","    \/\/ Generic error handling","    print(\"Action was cancelled: \\(error)\")","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"âœ… After (1.1):"}],"type":"paragraph"},{"code":["switch result {","case .successWithPrecedingCancellation(let cancellationError):","    \/\/ Type-safe access to cancellation information","    let cancelledAction = cancellationError.lockmanInfo.actionName","    let boundaryId = cancellationError.boundaryId","    print(\"Action '\\(cancelledAction)' was cancelled at boundary '\\(boundaryId)'\")","}"],"syntax":"swift","type":"codeListing"},{"level":3,"text":"Updating priority-based error handling","anchor":"Updating-priority-based-error-handling","type":"heading"},{"inlineContent":[{"text":"If youâ€™re handling specific ","type":"text"},{"code":"LockmanPriorityBasedError","type":"codeVoice"},{"text":" cases, update to use the new parameters:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"ðŸš« Before (1.0):","type":"text"}],"type":"paragraph"},{"code":["catch let error as LockmanPriorityBasedError {","    switch error {","    case .precedingActionCancelled(let actionName, let priority):","        print(\"Cancelled \\(actionName) with priority \\(priority)\")","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"âœ… After (1.1):","type":"text"}],"type":"paragraph"},{"code":["catch let error as LockmanPriorityBasedError {","    switch error {","    case .precedingActionCancelled(let actionName, let priority, let lockmanInfo, let boundaryId):","        print(\"Cancelled \\(actionName) with priority \\(priority)\")","        print(\"Full action info: \\(lockmanInfo.actionName)\")","        print(\"Boundary: \\(boundaryId)\")","    }","}"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Benefits of upgrading","anchor":"Benefits-of-upgrading","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Prevents resource leaks"}]},{"type":"text","text":": Immediate unlock ensures locks are released as soon as actions are cancelled"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Better debugging"}]},{"type":"text","text":": Enhanced error information provides complete context about cancelled actions"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Type safety"}],"type":"strong"},{"type":"text","text":": The new protocol ensures compile-time safety when accessing cancellation information"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Improved performance","type":"text"}],"type":"strong"},{"text":": Eliminates false lock conflicts caused by delayed unlock operations","type":"text"}]}]}],"type":"orderedList"},{"level":2,"text":"Complete example","anchor":"Complete-example","type":"heading"},{"inlineContent":[{"text":"Hereâ€™s a complete example showing how to migrate error handling code:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"ðŸš« Before (1.0):"}],"type":"paragraph"},{"code":[".withLock(","    operation: { send in","        \/\/ Long-running operation","    },","    action: action,","    boundaryId: CancelID.operation,","    lockFailure: { error, send in","        if let cancellationError = error as? LockmanCancellationError,","           case .precedingActionCancelled = cancellationError.reason as? LockmanPriorityBasedError {","            await send(.showMessage(\"Previous action was cancelled\"))","        }","    }",")"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"âœ… After (1.1):","type":"text"}],"type":"paragraph"},{"code":[".withLock(","    operation: { send in","        \/\/ Long-running operation","    },","    action: action,","    boundaryId: CancelID.operation,","    lockFailure: { error, send in","        if let cancellationError = error as? LockmanCancellationError,","           case .precedingActionCancelled(_, _, let lockmanInfo, let boundaryId) = cancellationError.reason as? LockmanPriorityBasedError {","            await send(.showMessage(\"Cancelled '\\(lockmanInfo.actionName)' at '\\(boundaryId)'\"))","        }","    }",")"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Summary","anchor":"Summary","type":"heading"},{"inlineContent":[{"type":"text","text":"Lockman 1.1 is a minor version update that includes breaking changes to improve resource management and type safety. While these changes require some code updates, they provide significant benefits in preventing resource leaks and improving debugging capabilities."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The immediate unlock functionality works transparently, ensuring your applicationâ€™s locks are properly managed without any additional code changes."}],"type":"paragraph"}],"kind":"content"}],"metadata":{"title":"Migrating to 1.1","roleHeading":"Article","role":"article","modules":[{"name":"Lockman"}]},"hierarchy":{"paths":[["doc:\/\/Lockman\/documentation\/Lockman"]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"abstract":[{"text":"Update your code from Lockman 1.0 to take advantage of Lockman 1.1â€™s improved resource management and enhanced error handling.","type":"text"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/lockman\/migratingto1.1"]}],"references":{"doc://Lockman/documentation/Lockman":{"abstract":[{"type":"text","text":"Elegant exclusive control for user actions in The Composable Architecture applications."}],"url":"\/documentation\/lockman","identifier":"doc:\/\/Lockman\/documentation\/Lockman","title":"Lockman","kind":"symbol","type":"topic","role":"collection"}}}