{"metadata":{"roleHeading":"Article","role":"article","modules":[{"name":"Lockman"}],"title":"Dynamic Condition Evaluation"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","text":"Overview","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The LockmanDynamicConditionReducer provides unified condition evaluation for both reducer-level and action-level exclusive processing. This enables flexible control over when actions should be executed based on dynamic runtime conditions."}]},{"type":"paragraph","inlineContent":[{"text":"Unlike traditional strategies that use fixed rules, dynamic condition evaluation allows you to implement complex business logic that evaluates state and actions at runtime to determine whether exclusive processing should be applied.","type":"text"}]},{"anchor":"Two-Level-Processing-Architecture","text":"Two-Level Processing Architecture","type":"heading","level":2},{"anchor":"Reducer-Level-Processing","text":"Reducer-Level Processing","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Automatic condition evaluation that applies to all actions processed by the reducer. This level is ideal for global constraints like authentication checks or system status validation.","type":"text"}]},{"anchor":"Action-Level-Processing","text":"Action-Level Processing","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Independent condition evaluation for specific actions using the ","type":"text"},{"type":"codeVoice","code":"lock"},{"text":" method. This level is perfect for operation-specific constraints like balance checks or business hour validation.","type":"text"}]},{"anchor":"Basic-Usage","text":"Basic Usage","type":"heading","level":2},{"anchor":"Simple-Reducer-Level-Condition","text":"Simple Reducer-Level Condition","type":"heading","level":3},{"code":["var body: some ReducerOf<Self> {","  Reduce { state, action in","    switch action {","    case .transfer(let amount):","      state.balance -= amount","      return .run { send in","        await send(.transferCompleted)","      }","    case .withdraw(let amount):","      state.balance -= amount","      return .run { send in","        await send(.withdrawCompleted)","      }","    default:","      return .none","    }","  }","  .lock(","    condition: { state, action in","      \/\/ Reducer-level condition: Check authentication for financial operations","      switch action {","      case .transfer, .withdraw:","        return state.isAuthenticated ? .success : .cancel(AuthError.notAuthenticated)","      default:","        return .success  \/\/ Allow other actions","      }","    },","    boundaryId: CancelID.authentication,","    lockFailure: { error, send in","      await send(.showError(error.localizedDescription))","    }","  )","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Action-Level-Condition-Evaluation","text":"Action-Level Condition Evaluation","type":"heading","level":3},{"code":["let reducer = LockmanDynamicConditionReducer<State, Action>(","  { state, action in","    \/\/ Base reducer implementation","    switch action {","    case .transfer(let amount):","      return .run { send in","        await processTransfer(amount)","        await send(.transferCompleted)","      }","    default:","      return .none","    }","  },","  condition: { _, _ in .success },  \/\/ Allow all actions at reducer level","  boundaryId: CancelID.operations",")","","\/\/ Use action-level conditions for specific operations","func handleTransfer(amount: Double, state: State) -> Effect<Action> {","  return reducer.lock(","    state: state,","    action: .transfer(amount),","    operation: { send in","      await processTransfer(amount)","      await send(.transferCompleted)","    },","    lockFailure: { error, send in","      await send(.showError(error.localizedDescription))","    },","    boundaryId: CancelID.transfer,","    lockCondition: { state, _ in","      \/\/ Action-level condition: Check balance","      guard state.balance >= amount else {","        return .cancel(TransferError.insufficientFunds(","          required: amount,","          available: state.balance","        ))","      }","      return .success","    }","  )","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Independent-Level-Processing","text":"Independent Level Processing","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Both levels operate independently, allowing you to combine global and specific constraints:"}]},{"code":["let reducer = LockmanDynamicConditionReducer<State, Action>(","  { state, action in","    switch action {","    case .performOperation:","      return .run { send in","        await send(.operationCompleted)","      }","    default:","      return .none","    }","  },","  condition: { state, action in","    \/\/ Reducer-level: Global authentication check","    switch action {","    case .performOperation:","      return state.isAuthenticated ? .success : .cancel(AuthError.notAuthenticated)","    default:","      return .success","    }","  },","  boundaryId: CancelID.auth,","  lockFailure: { error, send in","    await send(.showError(\"Auth failed: \\(error.localizedDescription)\"))","  }",")","","\/\/ Action-level processing with different conditions","func handleSecureOperation(state: State) -> Effect<Action> {","  return reducer.lock(","    state: state,","    action: .performOperation,","    operation: { send in","      await performSecureOperation()","      await send(.operationCompleted)","    },","    lockFailure: { error, send in","      await send(.showError(\"Operation failed: \\(error.localizedDescription)\"))","    },","    boundaryId: CancelID.secureOp,","    lockCondition: { state, _ in","      \/\/ Action-level: Additional security checks","      guard state.securityLevel >= .high else {","        return .cancel(SecurityError.insufficientPermissions)","      }","      return .success","    }","  )","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Cancellable-Effect-Control","text":"Cancellable Effect Control","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Both levels use cancellable effects to ensure proper resource management:"}]},{"code":["\/\/ Reducer-level cancellation",".lock(","  condition: { _, _ in .success },","  boundaryId: CancelID.operations  \/\/ Effects cancelled by this boundary",")","","\/\/ Action-level cancellation  ","reducer.lock(","  \/\/ ...","  boundaryId: CancelID.specificOperation  \/\/ Independent cancellation boundary",")"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"When multiple operations use the same boundary ID, newer operations will cancel previous ones automatically.","type":"text"}]},{"anchor":"Condition-Evaluation-Results","text":"Condition Evaluation Results","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"All conditions must return a "},{"type":"codeVoice","code":"LockmanResult"},{"type":"text","text":":"}]},{"code":["\/\/ Allow exclusive processing","return .success","","\/\/ Skip exclusive processing with error","return .cancel(MyError.conditionNotMet)","","\/\/ Allow with preceding cancellation (advanced usage)","return .successWithPrecedingCancellation(cancellationError)"],"syntax":"swift","type":"codeListing"},{"anchor":"Practical-Examples","text":"Practical Examples","type":"heading","level":2},{"anchor":"Business-Hours-Control","text":"Business Hours Control","type":"heading","level":3},{"code":[".lock(","  condition: { state, action in","    switch action {","    case .makeTransaction:","      let currentHour = Calendar.current.component(.hour, from: Date())","      guard (9...17).contains(currentHour) else {","        return .cancel(BusinessError.outsideBusinessHours)","      }","      return .success","    default:","      return .success","    }","  },","  boundaryId: CancelID.businessHours",")"],"syntax":"swift","type":"codeListing"},{"anchor":"Multi-Condition-Validation","text":"Multi-Condition Validation","type":"heading","level":3},{"code":["reducer.lock(","  state: state,","  action: action,","  operation: { send in","    await performComplexOperation()","    await send(.completed)","  },","  boundaryId: CancelID.complexOp,","  lockCondition: { state, action in","    \/\/ Multiple validation checks","    guard state.systemStatus == .ready else {","      return .cancel(SystemError.notReady)","    }","    ","    guard state.userPermissions.contains(.execute) else {","      return .cancel(PermissionError.insufficientRights)","    }","    ","    if case .processLargeData(let size) = action {","      guard size <= state.maxAllowedSize else {","        return .cancel(DataError.sizeExceeded)","      }","    }","    ","    return .success","  }",")"],"syntax":"swift","type":"codeListing"},{"anchor":"Error-Handling","text":"Error Handling","type":"heading","level":2},{"anchor":"Custom-Error-Types","text":"Custom Error Types","type":"heading","level":3},{"code":["enum BusinessError: Error, LocalizedError {","  case outsideBusinessHours","  case insufficientFunds(required: Double, available: Double)","  case dailyLimitExceeded(limit: Double)","  ","  var errorDescription: String? {","    switch self {","    case .outsideBusinessHours:","      return \"Operations only allowed during business hours (9:00-17:00)\"","    case .insufficientFunds(let required, let available):","      return \"Insufficient funds: Required $\\(required), Available $\\(available)\"","    case .dailyLimitExceeded(let limit):","      return \"Daily transaction limit of $\\(limit) exceeded\"","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Structured-Error-Handling","text":"Structured Error Handling","type":"heading","level":3},{"code":["lockFailure: { error, send in","  switch error {","  case let businessError as BusinessError:","    switch businessError {","    case .outsideBusinessHours:","      await send(.showBusinessHoursMessage)","    case .insufficientFunds(let required, let available):","      await send(.showInsufficientFundsDialog(required: required, available: available))","    case .dailyLimitExceeded(let limit):","      await send(.showDailyLimitWarning(limit: limit))","    }","  default:","    await send(.showGenericError(error.localizedDescription))","  }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Migration-from-Strategy-Based-Approach","text":"Migration from Strategy-Based Approach","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you were previously using the strategy-based DynamicConditionStrategy:"}]},{"anchor":"Before-Strategy-Based","text":"Before (Strategy-Based)","type":"heading","level":3},{"code":["\/\/ Old approach - no longer available","@LockmanDynamicCondition","enum Action {","  \/\/ ...","}"],"syntax":"swift","type":"codeListing"},{"anchor":"After-Unified-Condition-Evaluation","text":"After (Unified Condition Evaluation)","type":"heading","level":3},{"code":["\/\/ New approach - unified API",".lock(","  condition: { state, action in","    \/\/ Your condition logic here","    return .success","  },","  boundaryId: YourBoundaryId.dynamicConditions",")"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new approach provides the same flexibility with a cleaner, more predictable API that separates reducer-level and action-level concerns."}]}]}],"kind":"article","schemaVersion":{"patch":0,"major":0,"minor":3},"seeAlsoSections":[{"anchor":"Strategies","generated":true,"title":"Strategies","identifiers":["doc:\/\/Lockman\/documentation\/Lockman\/SingleExecutionStrategy","doc:\/\/Lockman\/documentation\/Lockman\/PriorityBasedStrategy","doc:\/\/Lockman\/documentation\/Lockman\/ConcurrencyLimitedStrategy","doc:\/\/Lockman\/documentation\/Lockman\/GroupCoordinationStrategy","doc:\/\/Lockman\/documentation\/Lockman\/CompositeStrategy"]}],"hierarchy":{"paths":[["doc:\/\/Lockman\/documentation\/Lockman"]]},"variants":[{"paths":["\/documentation\/lockman\/dynamicconditionstrategy"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"Control actions based on runtime conditions with unified condition evaluation."}],"identifier":{"url":"doc:\/\/Lockman\/documentation\/Lockman\/DynamicConditionStrategy","interfaceLanguage":"swift"},"sections":[],"references":{"doc://Lockman/documentation/Lockman/SingleExecutionStrategy":{"type":"topic","kind":"article","title":"SingleExecutionStrategy","role":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/SingleExecutionStrategy","abstract":[{"text":"Prevent duplicate execution of the same action.","type":"text"}],"url":"\/documentation\/lockman\/singleexecutionstrategy"},"doc://Lockman/documentation/Lockman/ConcurrencyLimitedStrategy":{"abstract":[{"type":"text","text":"Limit the number of concurrent executions."}],"identifier":"doc:\/\/Lockman\/documentation\/Lockman\/ConcurrencyLimitedStrategy","role":"article","title":"ConcurrencyLimitedStrategy","url":"\/documentation\/lockman\/concurrencylimitedstrategy","kind":"article","type":"topic"},"doc://Lockman/documentation/Lockman/CompositeStrategy":{"role":"article","type":"topic","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/CompositeStrategy","title":"CompositeStrategy","abstract":[{"text":"Combine multiple strategies for complex control scenarios.","type":"text"}],"url":"\/documentation\/lockman\/compositestrategy","kind":"article"},"doc://Lockman/documentation/Lockman/PriorityBasedStrategy":{"url":"\/documentation\/lockman\/prioritybasedstrategy","role":"article","title":"PriorityBasedStrategy","type":"topic","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/PriorityBasedStrategy","abstract":[{"text":"Control action execution based on priority levels.","type":"text"}],"kind":"article"},"doc://Lockman/documentation/Lockman":{"abstract":[{"type":"text","text":"Elegant exclusive control for user actions in The Composable Architecture applications."}],"url":"\/documentation\/lockman","identifier":"doc:\/\/Lockman\/documentation\/Lockman","title":"Lockman","kind":"symbol","type":"topic","role":"collection"},"doc://Lockman/documentation/Lockman/GroupCoordinationStrategy":{"url":"\/documentation\/lockman\/groupcoordinationstrategy","title":"GroupCoordinationStrategy","type":"topic","abstract":[{"type":"text","text":"Coordinate actions through leader\/member group roles."}],"role":"article","kind":"article","identifier":"doc:\/\/Lockman\/documentation\/Lockman\/GroupCoordinationStrategy"}}}